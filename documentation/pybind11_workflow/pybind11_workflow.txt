#######################################
Some general information about pybind11
#######################################
pybind11 is a header-only module that exposes C++ types in Python and vice versa. The documentation can be found here:
https://pybind11.readthedocs.io/en/stable/index.html

#######################################
Getting things to work from scratch
#######################################
1) Cloning the pybind11 repository
1.1) In your project directory, clone the pybind11 repository:

git clone git@github.com:pybind/pybind11.git

2) Create your python bindings
2.1) Create a yourPythonBindings.cpp file and include the pybind11 headers:

#include <pybind11/pybind11.h>

2.2) Write any function to be used in python
2.3) Create Pybind11_Module by calling 

PYBIND11_MODULE(module_name, handle){ .. }

2.3) Inside { .. } include cpp functions inside module by 

handle.def( "<functionNameInPython>", & <reference to cpp func> )

2.4) Inside { .. } include classes by 

pybind11::class_<ClassToBeAdded>(handle, <python class name>)
   .def(pybind11::init<inputargs datatypes>()) //constructor
   .def(<python member function name>, & <reference to cpp memberfunction>)

3) Build & compile
3.1) There are multiple ways to build pybind11 projects, but we focus on using cmake here, so make sure cmake is installed.
3.2) In your project directory, create a CMakeLists.txt and add the following lines:

cmake_minimum_required(VERSION 3.4)# Specify minimum cmake version
add_subdirectory(pybind11)# Include the pybind11 headers
pybind11_add_module(module_name yourPythonBindings.cpp)# Function provided by pybind11 that will add a library called module_name to be build from the specified yourPythonBindings.cpp
set(MODULE_OUTPUT_DIRECTORY "${CMAKE_CURRENT_BINARY_DIR}/module")# Specify the directory in which the created shared library (your compiled module, in a .so file) will be placed
file(MAKE_DIRECTORY ${MODULE_OUTPUT_DIRECTORY})# Create this directory
set_target_properties(module_name PROPERTIES LIBRARY_OUTPUT_DIRECTORY ${MODULE_OUTPUT_DIRECTORY})# Set the location of the compiled module

3.3) Create a /build folder in your project and cd into it
3.4) Inside /build, execute 

cmake ..

This will configure the build system by generating build files from the CMakeLists.txt

3.5) Inside /build, execute

cmake --build .

This will use the generated build files to compile and link the source code, producing the final binaries, i.e. your compiled module in a .so file

4) Use your bindings from python
4.1) First tell the python interpreter where to find your .so file. If you have followed the procedure above, your .so file should be located in /build/module/ inside your project directory. 
So you can create a testMyBindings.py file and populate it with the following lines:

import sys
import os

# Get the directory of the current script
script_dir = os.path.dirname(os.path.realpath(__file__))
# Append the relative path to the build module
sys.path.append(os.path.join(script_dir, "build", "module"))

import module_name
from module_name import *

# Test the binding:
module_name.functionNameInPython(..)

4.2) Now run your python script:

python3 testMyBindings.py

#######################################
Subsequent workflow
#######################################
Once you have conducted the procedure above, it is sufficient to run

cmake --build .

in your build folder once the binding definition has changed. After that the bindings should be updated and usable from within your python application.